<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Geometty Dash â€“ Final Correction</title>
<style>
  /* Full Page Setup */
  html, body { 
    margin: 0; padding: 0; width: 100%; height: 100%; 
    background: #000; overflow: hidden; touch-action: none;
    font-family: system-ui, sans-serif;
  }
  
  /* Canvas spans the whole screen */
  #gameCanvas { 
    display: block; width: 100vw; height: 100vh; 
    background: #000;
  }

  #uiLayer { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    display: flex; flex-direction: column; align-items: center; 
    justify-content: center; pointer-events: none; 
  }

  .btn { 
    padding: 15px 30px; font-size: 20px; font-weight: bold; color: white; 
    background: #22c55e; border: none; border-radius: 8px; cursor: pointer; 
    pointer-events: auto; display: none;
  }

  #scoreBoard { 
    position: absolute; top: 10px; left: 10px; color: white; 
    font-weight: bold; font-size: 18px; pointer-events: none; 
    text-shadow: 2px 2px 4px black; 
  }
</style>
</head>
<body>
<div id="scoreBoard">Best: 0%</div>
<canvas id="gameCanvas" width="960" height="540"></canvas>
<div id="uiLayer"><button id="newLevelBtn" class="btn">GENERATE NEW WORLD</button></div>

<script>
(function(){
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const btn = document.getElementById("newLevelBtn");
const scoreBoard = document.getElementById("scoreBoard");

// Internal resolution stays 960x540 for original physics
const W = 960, H = 540;

const baseGroundY = H * 0.75;
const cubeSize = 32;
const gravity = 0.98;      
const jumpVel = -13.8;   
const moveSpeed = 9.2;     
const levelLength = 45000; 

let x, y, vy, onGround, started, dead, shake, cameraX = 0, cameraY = 0;
let introDone = false, hue = 0, won = false, bang = 0, cutsceneT = 0;
let charColor1, charColor2, rotation = 0, inputActive = false;
let lastCheckpointX = 120, checkpointFlash = 0;
let highScore = localStorage.getItem("gd_highscore") || 0;

function updateHighScoreDisplay() {
    scoreBoard.innerText = `Best: ${highScore}%`;
}
updateHighScoreDisplay();

// --- AUDIO SYSTEM (ORIGINAL) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let nextNoteTime = 0;
let beatIndex = 0;
const melody = [261.63, 311.13, 349.23, 311.13, 392.00, 349.23, 311.13, 233.08]; 

function playSynth(freq, time, vol, detune = 0, type = "square", decay = 0.2, slideTo = null) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, time);
    if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, time + decay);
    osc.detune.setValueAtTime(detune, time);
    gain.gain.setValueAtTime(vol, time);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + decay);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(time);
    osc.stop(time + decay);
}

function updateAudio() {
    if (!started || dead || won || audioCtx.state === 'suspended') return;
    const isFinale = x > levelLength * 0.82;
    const prog = Math.max(0, Math.min(1, (x - hillEndX) / (levelLength - hillEndX)));
    let tempo = isFinale ? 0.07 : (0.15 - (prog * 0.05));

    if (audioCtx.currentTime > nextNoteTime) {
        if (!isFinale) {
            playSynth(50, nextNoteTime, 0.4, 0, "sine", 0.3); 
            playSynth(melody[beatIndex % melody.length], nextNoteTime, 0.12, 0, "square", 0.2); 
            if (beatIndex % 4 === 0) playSynth(melody[(beatIndex + 2) % melody.length] * 2, nextNoteTime, 0.05, 10, "triangle", 0.4); 
            if (beatIndex % 4 === 2) playSynth(800, nextNoteTime, 0.08, 50, "sawtooth", 0.05); 
        } else {
            const creepyFreq = 100 + Math.random() * 50;
            playSynth(creepyFreq, nextNoteTime, 0.4, Math.random() * 1000, "sawtooth", 0.1);
            if(beatIndex % 3 === 0) playSynth(800 + Math.random() * 1000, nextNoteTime, 0.05, 0, "sine", 0.5, 50);
        }
        nextNoteTime = audioCtx.currentTime + tempo;
        beatIndex++;
    }
}

const segments = [], trail = [];
const hillStartX = 0, hillEndX = 2500;
const checkpoints = [0.2, 0.4, 0.6, 0.8].map(p => hillEndX + (levelLength * 0.82 - hillEndX) * p);

function generateLevel() {
  segments.length = 0;
  let curX = hillEndX + 800;
  while (curX < levelLength * 0.80) {
    let nearCheckpoint = checkpoints.some(cx => Math.abs(curX - cx) < 250);
    if (!nearCheckpoint) {
        const count = Math.random() > 0.8 ? 3 : (Math.random() > 0.6 ? 2 : 1);
        for(let i=0; i<count; i++) segments.push({ x: curX + (i*32), w: 32 });
    }
    curX += 450 + Math.random() * 350;
  }
}

function reset(newWorld = false) {
  if (newWorld) { generateLevel(); introDone = false; lastCheckpointX = 120; }
  x = lastCheckpointX; y = groundYAt(x) - cubeSize;
  vy = 0; rotation = 0; onGround = true; started = false; dead = false; 
  won = false; bang = 0; cutsceneT = 0; shake = 0;
  btn.style.display = "none";
  const h = Math.random() * 360;
  charColor1 = `hsl(${h}, 100%, 50%)`; charColor2 = `hsl(${(h+40)%360}, 100%, 70%)`;
  trail.length = 0;
}

function groundYAt(worldX) {
  if (!introDone && worldX < hillEndX + 100) {
    const p = Math.max(0, Math.min(1, (worldX - hillStartX) / (hillEndX - hillStartX)));
    if (p < 0.8) return baseGroundY - Math.pow(p / 0.8, 5) * 1100;
    if (p < 0.9) return baseGroundY - 1100;
    return (baseGroundY - 1100) + ((p - 0.9) / 0.1) * 1100;
  }
  return (worldX > levelLength * 0.98) ? 9999 : baseGroundY;
}

function update() {
  updateAudio();
  if (dead || won || !started) { if(won) cutsceneT++; return; }
  hue = (hue + 1) % 360;
  if (shake > 0) shake *= 0.9;
  if (checkpointFlash > 0) checkpointFlash -= 0.05;
  
  x += moveSpeed; vy += gravity; y += vy;
  const curFloor = groundYAt(x);

  if (y + cubeSize >= curFloor) {
    y = curFloor - cubeSize;
    if (x >= hillEndX && !introDone) {
        introDone = true;
        shake = 25; vy = 0; onGround = true;
    } else {
        vy = 0; onGround = true;
        if (inputActive && introDone) { vy = jumpVel; onGround = false; }
    }
  } else { onGround = false; }

  if (!onGround) rotation += 0.18;
  else rotation = Math.round(rotation / (Math.PI/2)) * (Math.PI/2);

  checkpoints.forEach(cx => { if (x > cx && lastCheckpointX < cx) { lastCheckpointX = cx; checkpointFlash = 1; } });

  const progInt = Math.floor(Math.max(0, Math.min(1, (x - hillEndX) / (levelLength - hillEndX))) * 100);
  if (progInt > highScore) {
      highScore = progInt;
      localStorage.setItem("gd_highscore", highScore);
      updateHighScoreDisplay();
  }

  if (x > levelLength * 0.98 && y > H + 200) { 
    won = true; bang = 1; 
    setTimeout(() => { btn.style.display = "block"; }, 9000); 
  }

  if (introDone) {
    for (const s of segments) {
      if (x + 8 < s.x + s.w && x + cubeSize - 8 > s.x && y + 20 > baseGroundY - 32) { die(); return; }
    }
  }
  cameraX += (x - 250 - cameraX) * 0.15;
  cameraY += ((y - H * 0.5) - cameraY) * 0.15;
  trail.push({ x, y, hue: hue }); if (trail.length > 12) trail.shift();
}

function die() { dead = true; shake = 25; setTimeout(() => reset(false), 500); }

function draw() {
  if (won && bang >= 1) { drawEndingCinematic(); requestAnimationFrame(draw); return; }
  
  // Clear the real screen dimensions
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Setup the original 960x540 aspect ratio
  const scale = Math.min(canvas.width / W, canvas.height / H);
  ctx.setTransform(scale, 0, 0, scale, (canvas.width - W * scale) / 2, (canvas.height - H * scale) / 2);

  const isFinale = x > levelLength * 0.82;
  ctx.fillStyle = isFinale ? "#000" : `hsl(${hue}, 50%, 15%)`; ctx.fillRect(0,0,W,H);
  
  ctx.save();
  ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
  ctx.translate(-cameraX, -cameraY);

  ctx.fillStyle = "black";
  ctx.beginPath(); ctx.moveTo(cameraX-200, H*6);
  for(let i=cameraX-200; i<x+W*1.5; i+=40) { 
    let gy = groundYAt(i);
    ctx.lineTo(i, gy); 
  }
  ctx.lineTo(x+W*1.5, H*6); ctx.fill();

  checkpoints.forEach(cx => {
      ctx.fillStyle = lastCheckpointX >= cx ? "#0ff" : "#555";
      ctx.fillRect(cx, baseGroundY - 80, 4, 80);
      ctx.beginPath(); ctx.moveTo(cx+4, baseGroundY-80); ctx.lineTo(cx+40, baseGroundY-60); ctx.lineTo(cx+4, baseGroundY-40); ctx.fill();
  });

  if (isFinale) {
    const stalkerX = x - 450 + Math.sin(Date.now()*0.005)*120;
    ctx.fillStyle = "black"; ctx.font = "bold 600px Arial";
    ctx.fillText("ðŸ’€", stalkerX - 250, y + 200); 
    ctx.fillStyle = "red"; ctx.shadowBlur = 40; ctx.shadowColor = "red";
    ctx.fillRect(stalkerX - 150, y - 60, 60, 60); ctx.fillRect(stalkerX + 20, y - 60, 60, 60);
    ctx.shadowBlur = 0; shake = 15;
  }

  ctx.fillStyle = "#ff3333";
  for (const s of segments) {
    ctx.beginPath(); ctx.moveTo(s.x, baseGroundY); ctx.lineTo(s.x+16, baseGroundY-32); ctx.lineTo(s.x+32, baseGroundY); ctx.fill();
  }

  if (!introDone) {
    ctx.save(); ctx.font = "bold 48px Arial"; ctx.textAlign = "center";
    ctx.shadowColor = "cyan"; ctx.shadowBlur = 20; ctx.fillStyle = "white";
    ctx.fillText("Geometty Dash by Jaap", x, y - 110); ctx.restore();
  }

  trail.forEach((t, i) => {
      ctx.globalAlpha = i / trail.length;
      ctx.fillStyle = `hsl(${t.hue}, 100%, 50%)`;
      ctx.fillRect(t.x, t.y, cubeSize, cubeSize);
  });
  ctx.globalAlpha = 1;

  ctx.save(); ctx.translate(x+16, y+16); ctx.rotate(rotation);
  const grad = ctx.createLinearGradient(-16,-16,16,16); grad.addColorStop(0, charColor1); grad.addColorStop(1, charColor2);
  ctx.fillStyle = grad; ctx.fillRect(-16,-16,32,32); ctx.strokeStyle = "white"; ctx.strokeRect(-16,-16,32,32);
  ctx.restore();
  ctx.restore();

  const prog = Math.max(0, Math.min(1, (x - hillEndX) / (levelLength - hillEndX)));
  ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(W/2 - 150, 20, 300, 25);
  ctx.fillStyle = isFinale ? "#f00" : `hsl(${hue}, 100%, 50%)`; ctx.fillRect(W/2 - 150, 20, 300 * prog, 25);
  ctx.fillStyle = "white"; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
  ctx.fillText(isFinale ? "RUN." : `${Math.floor(prog * 100)}%`, W/2, 38);

  if (checkpointFlash > 0) { ctx.fillStyle = `rgba(0, 255, 0, ${checkpointFlash * 0.3})`; ctx.fillRect(0,0,W,H); }
  requestAnimationFrame(draw);
}

function drawEndingCinematic() {
  const t = cutsceneT;
  if (t < 150) { 
    ctx.fillStyle = "white"; ctx.fillRect(0,0,W,H);
    ctx.save(); ctx.translate(W/2, H/2 + t); ctx.rotate(t*0.05);
    const g = ctx.createLinearGradient(-16,-16,16,16); g.addColorStop(0, charColor1); g.addColorStop(1, charColor2);
    ctx.fillStyle = g; ctx.fillRect(-16,-16,32,32); ctx.restore();
    ctx.fillStyle = "red"; ctx.globalAlpha = Math.min(1, t/100);
    ctx.fillRect(W/2 - 300, 100, 20, 20); ctx.fillRect(W/2 + 300, 100, 20, 20); ctx.globalAlpha = 1;
    return;
  }
  if (t < 200) { ctx.fillStyle = "white"; ctx.fillRect(0,0,W,H); return; }
  const spaceT = t - 200;
  ctx.fillStyle = "#000510"; ctx.fillRect(0,0,W,H);
  for(let i=0; i<60; i++) { ctx.fillStyle = "white"; ctx.fillRect((i*137)%W, (i*531 + spaceT*4)%H, 2, 2); }
  const earthS = Math.max(10, 500 - spaceT*1.2);
  const ex = W/2, ey = H/2; 
  ctx.fillStyle = "#2255ff"; ctx.beginPath(); ctx.arc(ex, ey, earthS, 0, Math.PI*2); ctx.fill();
  if (earthS > 15) {
    ctx.fillStyle = "#3a3"; ctx.beginPath(); ctx.arc(ex - earthS*0.3, ey - earthS*0.2, earthS*0.4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(ex + earthS*0.2, ey - earthS*0.1, Math.max(2, earthS*0.1), 0, Math.PI*2); ctx.fill();
  }
  ctx.save(); ctx.translate(W/2 + Math.sin(spaceT*0.1)*10, H/2 - Math.min(150, spaceT*2));
  ctx.fillStyle = spaceT % 4 < 2 ? "#fa0" : "#f40";
  ctx.beginPath(); ctx.moveTo(-18, 30); ctx.lineTo(0, 75); ctx.lineTo(18, 30); ctx.fill();
  ctx.fillStyle = "#ddd"; ctx.beginPath(); ctx.moveTo(0, -60); ctx.lineTo(40, 25); ctx.lineTo(-40, 25); ctx.closePath(); ctx.fill();
  const g = ctx.createLinearGradient(-8,-8,8,8); g.addColorStop(0, charColor1); g.addColorStop(1, charColor2);
  ctx.fillStyle = g; ctx.fillRect(-8, -8, 16, 16); ctx.restore();
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

btn.addEventListener("click", () => reset(true));
const handleInput = (v) => { 
    if(!started) { started = true; if(audioCtx.state === 'suspended') audioCtx.resume(); }
    inputActive = v; 
    if(v && onGround && introDone) { vy = jumpVel; onGround = false; } 
};

window.addEventListener("keydown", (e)=>{ 
    if(e.code==="Space" || e.code==="ArrowUp" || e.code==="KeyW") handleInput(true); 
});
window.addEventListener("keyup", (e)=>{ 
    if(e.code==="Space" || e.code==="ArrowUp" || e.code==="KeyW") handleInput(false); 
});
canvas.addEventListener("mousedown", () => handleInput(true));
canvas.addEventListener("mouseup", () => handleInput(false));
canvas.addEventListener("touchstart", (e) => { e.preventDefault(); handleInput(true); }, {passive: false});
canvas.addEventListener("touchend", () => handleInput(false));

generateLevel(); reset(); draw(); setInterval(update, 1000/60);
})();
</script>
</body>
</html>
