<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Geometty Dash â€“ Ultra Edition</title>
<style>
  /* Full Page Setup */
  html, body { 
    margin: 0; padding: 0; width: 100%; height: 100%; 
    background: #000; overflow: hidden; touch-action: none;
  }
  
  /* Canvas spans the whole screen */
  #gameCanvas { 
    display: block; width: 100vw; height: 100vh; 
    image-rendering: pixelated; /* Keeps it sharp */
  }

  #uiLayer { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
    display: flex; flex-direction: column; align-items: center; 
    justify-content: center; pointer-events: none; 
    font-family: 'Segoe UI', sans-serif;
  }

  .btn { 
    padding: 20px 40px; font-size: 24px; font-weight: 900; color: white; 
    background: linear-gradient(180deg, #22c55e 0%, #166534 100%);
    border: 3px solid #fff; border-radius: 50px; cursor: pointer; 
    pointer-events: auto; display: none; box-shadow: 0 0 20px #22c55e;
    text-transform: uppercase; letter-spacing: 2px;
  }

  #scoreBoard { 
    position: absolute; top: 20px; left: 20px; color: white; 
    font-weight: bold; font-size: 24px; pointer-events: none; 
    text-shadow: 0 0 10px rgba(0,255,255,0.8);
  }
</style>
</head>
<body>
<div id="scoreBoard">BEST: 0%</div>
<canvas id="gameCanvas"></canvas>
<div id="uiLayer"><button id="newLevelBtn" class="btn">New World</button></div>

<script>
(function(){
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const btn = document.getElementById("newLevelBtn");
const scoreBoard = document.getElementById("scoreBoard");

// --- DYNAMIC SCALING ---
let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const baseGroundY = () => H * 0.75;
const cubeSize = 40;
const gravity = 0.98;      
const jumpVel = -16;   
const moveSpeed = 10;     
const levelLength = 50000; 

let x, y, vy, onGround, started, dead, shake, cameraX = 0, cameraY = 0;
let introDone = false, hue = 0, won = false, cutsceneT = 0;
let charColor1, charColor2, rotation = 0, inputActive = false;
let lastCheckpointX = 120, checkpointFlash = 0;
let highScore = localStorage.getItem("gd_highscore") || 0;

function updateHighScoreDisplay() {
    scoreBoard.innerText = `BEST: ${highScore}%`;
}
updateHighScoreDisplay();

// --- PRO AUDIO ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let nextNoteTime = 0, beatIndex = 0;
const melody = [261.63, 311.13, 349.23, 392.00, 466.16, 523.25]; 

function playSynth(freq, time, vol, type = "square", decay = 0.2) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, time);
    gain.gain.setValueAtTime(vol, time);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + decay);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(time); osc.stop(time + decay);
}

function updateAudio() {
    if (!started || dead || won || audioCtx.state === 'suspended') return;
    if (audioCtx.currentTime > nextNoteTime) {
        playSynth(60, nextNoteTime, 0.3, "sine", 0.4); // Bass Kick
        playSynth(melody[beatIndex % melody.length], nextNoteTime, 0.1, "sawtooth", 0.2);
        nextNoteTime = audioCtx.currentTime + 0.15;
        beatIndex++;
    }
}

const segments = [], trail = [];
const checkpoints = [0.2, 0.4, 0.6, 0.8].map(p => 2500 + (levelLength * 0.82 - 2500) * p);

function generateLevel() {
  segments.length = 0;
  let curX = 3300;
  while (curX < levelLength * 0.80) {
    segments.push({ x: curX, w: 40 });
    curX += 400 + Math.random() * 400;
  }
}

function reset(newWorld = false) {
  if (newWorld) { generateLevel(); introDone = false; lastCheckpointX = 120; }
  x = lastCheckpointX; y = groundYAt(x) - cubeSize;
  vy = 0; rotation = 0; onGround = true; started = false; dead = false; won = false;
  btn.style.display = "none";
  const h = Math.random() * 360;
  charColor1 = `hsl(${h}, 100%, 50%)`; charColor2 = `hsl(${(h+40)%360}, 100%, 70%)`;
  trail.length = 0;
}

function groundYAt(worldX) {
  if (!introDone && worldX < 2500) {
    let p = Math.max(0, Math.min(1, worldX / 2500));
    if (p < 0.8) return baseGroundY() - 1000;
    return (baseGroundY() - 1000) + ((p - 0.8) / 0.2) * 1000;
  }
  return (worldX > levelLength * 0.98) ? 9999 : baseGroundY();
}

function update() {
  updateAudio();
  if (dead || won || !started) { if(won) cutsceneT++; return; }
  hue = (hue + 1) % 360;
  if (shake > 0) shake *= 0.9;
  if (checkpointFlash > 0) checkpointFlash -= 0.05;
  
  x += moveSpeed; vy += gravity; y += vy;
  const curFloor = groundYAt(x);

  if (y + cubeSize >= curFloor) {
    y = curFloor - cubeSize;
    if (x >= 2500 && !introDone) { introDone = true; shake = 30; }
    vy = 0; onGround = true;
    if (inputActive && introDone) { vy = jumpVel; onGround = false; }
  } else { onGround = false; }

  if (!onGround) rotation += 0.2;
  else rotation = Math.round(rotation / (Math.PI/2)) * (Math.PI/2);

  checkpoints.forEach(cx => { if (x > cx && lastCheckpointX < cx) { lastCheckpointX = cx; checkpointFlash = 1; } });

  const progInt = Math.floor(Math.max(0, Math.min(1, x / levelLength)) * 100);
  if (progInt > highScore) { highScore = progInt; localStorage.setItem("gd_highscore", highScore); updateHighScoreDisplay(); }

  if (x > levelLength * 0.98 && y > H + 200) { won = true; setTimeout(() => { btn.style.display = "block"; }, 3000); }

  if (introDone) {
    for (const s of segments) {
      if (x + 10 < s.x + s.w && x + cubeSize - 10 > s.x && y + cubeSize > baseGroundY() - 20) { die(); return; }
    }
  }

  cameraX += (x - W * 0.3 - cameraX) * 0.1;
  cameraY += ((y - H * 0.5) - cameraY) * 0.1;
  trail.push({ x, y, hue }); if (trail.length > 15) trail.shift();
}

function die() { dead = true; shake = 40; setTimeout(() => reset(false), 400); }

function draw() {
  ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);
  
  ctx.save();
  ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
  ctx.translate(-cameraX, -cameraY);

  // Background Glow
  const bgGrad = ctx.createRadialGradient(x, y, 0, x, y, 800);
  bgGrad.addColorStop(0, `hsla(${hue}, 50%, 20%, 0.3)`);
  bgGrad.addColorStop(1, "transparent");
  ctx.fillStyle = bgGrad; ctx.fillRect(cameraX, cameraY, W, H);

  // Ground
  ctx.fillStyle = "#111"; ctx.fillRect(cameraX - 100, baseGroundY(), W + 1000, H);
  ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`; ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(cameraX - 100, baseGroundY()); ctx.lineTo(x + W, baseGroundY()); ctx.stroke();

  // Spikes
  ctx.fillStyle = "#ff0044";
  for (const s of segments) {
    ctx.beginPath(); ctx.moveTo(s.x, baseGroundY()); ctx.lineTo(s.x+20, baseGroundY()-40); ctx.lineTo(s.x+40, baseGroundY()); ctx.fill();
  }

  // Player Trail
  trail.forEach((t, i) => {
      ctx.globalAlpha = i / trail.length;
      ctx.fillStyle = `hsl(${t.hue}, 100%, 50%)`;
      ctx.fillRect(t.x, t.y, cubeSize, cubeSize);
  });
  ctx.globalAlpha = 1;

  // Player
  ctx.save(); ctx.translate(x + cubeSize/2, y + cubeSize/2); ctx.rotate(rotation);
  ctx.shadowBlur = 15; ctx.shadowColor = charColor1;
  ctx.fillStyle = charColor1; ctx.fillRect(-cubeSize/2, -cubeSize/2, cubeSize, cubeSize);
  ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.strokeRect(-cubeSize/2, -cubeSize/2, cubeSize, cubeSize);
  ctx.restore();
  
  ctx.restore();

  // Progress Bar
  const prog = Math.min(1, x / levelLength);
  ctx.fillStyle = "rgba(255,255,255,0.1)"; ctx.fillRect(W/2 - 200, 20, 400, 10);
  ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.fillRect(W/2 - 200, 20, 400 * prog, 10);

  if (checkpointFlash > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${checkpointFlash * 0.2})`; ctx.fillRect(0,0,W,H); }
  requestAnimationFrame(draw);
}

btn.addEventListener("click", () => reset(true));
const handleInput = (v) => { 
    if(!started) { started = true; if(audioCtx.state === 'suspended') audioCtx.resume(); }
    inputActive = v; 
};

window.addEventListener("keydown", (e)=>handleInput(true));
window.addEventListener("keyup", (e)=>handleInput(false));
canvas.addEventListener("touchstart", (e) => { e.preventDefault(); handleInput(true); }, {passive: false});
canvas.addEventListener("touchend", () => handleInput(false));

generateLevel(); reset(); draw(); setInterval(update, 1000/60);
})();
</script>
</body>
</html>
