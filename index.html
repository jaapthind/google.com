<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTRA PENALTY: IMPACT EDITION</title>
    <style>
        :root { --accent: #00f2ff; --gold: #ffd700; --danger: #ff4444; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #hud { position: absolute; inset: 0; pointer-events: none; z-index: 10; color: #fff; }
        .score-card { position: absolute; top: 40px; left: 40px; background: rgba(0,0,0,0.8); padding: 20px 35px; border-radius: 4px; border-left: 6px solid var(--accent); backdrop-filter: blur(10px); }
        .score-label { font-size: 10px; text-transform: uppercase; letter-spacing: 3px; color: #888; }
        .score-num { font-size: 48px; font-weight: 900; font-style: italic; display: block; }
        #power-system { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 350px; opacity: 0; transition: opacity 0.2s; }
        .bar-outer { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 10px; border: 1px solid rgba(255,255,255,0.3); overflow: hidden; }
        #bar-inner { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--gold), var(--danger)); box-shadow: 0 0 20px var(--accent); }
        #announcer { position: absolute; top: 35%; width: 100%; text-align: center; opacity: 0; transform: scale(0.5); transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #announcer.active { opacity: 1; transform: scale(1.1); }
        .msg { font-size: 100px; font-weight: 900; font-style: italic; -webkit-text-stroke: 2px black; text-transform: uppercase; }
    </style>
</head>
<body>

<div id="hud">
    <div class="score-card">
        <span class="score-label">Streak Scored</span>
        <span id="score-val" class="score-num">0</span>
    </div>
    <div id="announcer"><div id="msg-text" class="msg">GOAL!</div></div>
    <div id="power-system">
        <div class="score-label" style="text-align: center; margin-bottom: 10px;">Shot Power & Curve</div>
        <div class="bar-outer"><div id="bar-inner"></div></div>
    </div>
</div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

const SETTINGS = {
    GRAVITY: -0.018,
    AIR_DRAG: 0.994,
    MAGNUS: 0.0015,
    BOUNCE: 0.5,
    GOAL_Z: -50,
    BALL_START: new THREE.Vector3(0, 0.55, 15),
    GK_REACTION: 0.08
};

class GameEngine {
    constructor() {
        this.initCore();
        this.initStadium();
        this.initActors();
        this.initInput();
        this.resetGame();
        this.clock = new THREE.Clock();
        this.score = 0;
        this.state = 'READY';
        this.shakeIntensity = 0;
        this.animate();
    }

    initCore() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x020617);
        this.scene.fog = new THREE.FogExp2(0x020617, 0.012);
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(10, 40, 20);
        light.castShadow = true;
        this.scene.add(light);
    }

    initStadium() {
        const pitch = new THREE.Mesh(new THREE.PlaneGeometry(120, 250), new THREE.MeshStandardMaterial({ color: 0x166534 }));
        pitch.rotation.x = -Math.PI / 2; pitch.receiveShadow = true;
        this.scene.add(pitch);

        // Goal Posts
        const postMat = new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 0.1 });
        this.lp = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 10, 20), postMat); this.lp.position.set(-10, 5, SETTINGS.GOAL_Z);
        this.rp = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 10, 20), postMat); this.rp.position.set(10, 5, SETTINGS.GOAL_Z);
        this.bar = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 20.7, 20), postMat);
        this.bar.rotation.z = Math.PI/2; this.bar.position.set(0, 10, SETTINGS.GOAL_Z);
        this.scene.add(this.lp, this.rp, this.bar);

        // RESPONSIVE GOAL NET
        const netGeo = new THREE.PlaneGeometry(20, 10, 30, 20);
        const netMat = new THREE.MeshPhongMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        this.net = new THREE.Mesh(netGeo, netMat);
        this.net.position.set(0, 5, SETTINGS.GOAL_Z - 1.5);
        this.scene.add(this.net);
        this.netDefaultVertices = netGeo.attributes.position.array.slice();
    }

    initActors() {
        this.ball = new THREE.Mesh(new THREE.SphereGeometry(0.55, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        this.ball.castShadow = true; this.scene.add(this.ball);
        this.keeper = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.7, 1.8, 8, 16), new THREE.MeshStandardMaterial({color: 0xef4444}));
        body.position.y = 1.6; this.keeper.add(body);
        this.keeper.position.set(0, 0, SETTINGS.GOAL_Z + 1.5); this.scene.add(this.keeper);
        this.aimerGeo = new THREE.BufferGeometry();
        this.aimer = new THREE.Line(this.aimerGeo, new THREE.LineBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.4 }));
        this.scene.add(this.aimer);
    }

    initInput() {
        this.dragStart = new THREE.Vector2();
        this.vel = new THREE.Vector3();
        this.curve = 0;
        window.addEventListener('pointerdown', e => {
            if(this.state !== 'READY') return;
            this.state = 'AIMING'; this.dragStart.set(e.clientX, e.clientY);
            document.getElementById('power-system').style.opacity = '1';
        });
        window.addEventListener('pointermove', e => {
            if(this.state !== 'AIMING') return;
            const dx = this.dragStart.x - e.clientX;
            const dy = this.dragStart.y - e.clientY;
            const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.45, 100);
            document.getElementById('bar-inner').style.width = power + '%';
            this.vel.set(dx * 0.0055, dy * 0.009, -power * 0.025);
            this.curve = dx * 0.0012;
            this.updateTrajectory();
        });
        window.addEventListener('pointerup', () => {
            if(this.state !== 'AIMING') return;
            this.state = 'FLIGHT';
            document.getElementById('power-system').style.opacity = '0';
            this.aimer.geometry.setFromPoints([]);
            const t = Math.abs((SETTINGS.GOAL_Z - this.ball.position.z) / this.vel.z);
            this.keeperX = (this.ball.position.x + (this.vel.x * t)) * 0.8;
        });
    }

    updateTrajectory() {
        const pts = []; let p = this.ball.position.clone(); let v = this.vel.clone();
        for(let i=0; i<45; i++) {
            pts.push(p.clone()); p.add(v);
            v.x += this.curve * v.z * -SETTINGS.MAGNUS; v.y += SETTINGS.GRAVITY;
            if(p.y < 0.55 || p.z < SETTINGS.GOAL_Z) break;
        }
        this.aimer.geometry.setFromPoints(pts);
    }

    updateNet() {
        const posArr = this.net.geometry.attributes.position.array;
        const ballPos = this.ball.position;
        for (let i = 0; i < posArr.length; i += 3) {
            const vx = posArr[i] + this.net.position.x;
            const vy = posArr[i + 1] + this.net.position.y;
            const vz = posArr[i + 2] + this.net.position.z;
            const dist = ballPos.distanceTo(new THREE.Vector3(vx, vy, vz));
            if (dist < 2.5 && ballPos.z < SETTINGS.GOAL_Z) {
                const force = (2.5 - dist) * 0.5;
                posArr[i + 2] -= force; // Bulge net backward
            } else {
                posArr[i + 2] = THREE.MathUtils.lerp(posArr[i + 2], 0, 0.1); // Snap back
            }
        }
        this.net.geometry.attributes.position.needsUpdate = true;
    }

    resetGame() {
        this.state = 'READY'; this.ball.position.copy(SETTINGS.BALL_START);
        this.vel.set(0,0,0); this.keeper.position.x = 0;
        document.getElementById('announcer').classList.remove('active');
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        const dt = this.clock.getDelta() * 60;
        if(this.state === 'FLIGHT') {
            this.ball.position.add(this.vel.clone().multiplyScalar(dt));
            this.vel.y += SETTINGS.GRAVITY * dt;
            this.vel.x += this.curve * this.vel.z * -SETTINGS.MAGNUS * dt;
            this.keeper.position.x = THREE.MathUtils.lerp(this.keeper.position.x, this.keeperX, SETTINGS.GK_REACTION * dt);
            
            // PHYSICS: CROSSBAR & POSTS
            const b = this.ball.position;
            const inZ = Math.abs(b.z - SETTINGS.GOAL_Z) < 0.6;
            const hitBar = inZ && Math.abs(b.x) < 10.3 && Math.abs(b.y - 10) < 0.6;
            const hitPost = inZ && b.y < 10.3 && Math.abs(Math.abs(b.x) - 10) < 0.6;

            if(hitBar || hitPost) {
                this.vel.z *= -0.7; this.vel.y += 0.1;
                this.shakeIntensity = 0.6; // Heavy shake for woodwork
            }

            this.updateNet();

            if(b.z < SETTINGS.GOAL_Z - 5) {
                const isGoal = Math.abs(b.x) < 10 && b.y < 10 && b.y > 0.5;
                this.state = 'RESOLVED';
                if(isGoal) {
                    this.score++; document.getElementById('score-val').innerText = this.score;
                    this.announce("GOAL!", "#00f2ff");
                } else { this.announce("MISS!", "#ffffff"); }
            }
            this.camera.position.lerp(new THREE.Vector3(b.x * 0.4, 6, b.z + 15), 0.1 * dt);
        }
        if(this.shakeIntensity > 0) {
            this.camera.position.x += (Math.random()-0.5) * this.shakeIntensity;
            this.shakeIntensity *= 0.9;
        }
        this.camera.lookAt(0, 3, SETTINGS.GOAL_Z + 10);
        this.renderer.render(this.scene, this.camera);
    }

    announce(txt, color) {
        const el = document.getElementById('announcer');
        document.getElementById('msg-text').innerText = txt;
        document.getElementById('msg-text').style.color = color;
        el.classList.add('active');
        setTimeout(() => this.resetGame(), 1800);
    }
}
new GameEngine();
</script>
</body>
</html>
