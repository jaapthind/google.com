<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Kart Bros Ultra</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial Black', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px #f04; pointer-events: none; }
        #speed { position: absolute; bottom: 30px; right: 30px; color: #0ff; font-size: 40px; font-weight: 900; font-style: italic; }
        #mobile-controls { position: absolute; bottom: 20px; left: 20px; display: none; gap: 10px; }
        .joy-btn { width: 80px; height: 80px; background: rgba(255,255,255,0.2); border: 3px solid #fff; border-radius: 50%; color: white; font-size: 24px; display: flex; align-items: center; justify-content: center; pointer-events: auto; }
        @media (max-width: 768px) { #mobile-controls { display: flex; } }
    </style>
</head>
<body>
    <div id="ui">
        <h1>KART BROS 3D</h1>
        <div>LAP: <span id="lap-count">1 / 3</span></div>
        <div id="status">RACING...</div>
    </div>
    <div id="speed">0 KM/H</div>
    <div id="mobile-controls">
        <div class="joy-btn" id="btn-left">◀</div>
        <div class="joy-btn" id="btn-accel">▲</div>
        <div class="joy-btn" id="btn-right">▶</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CORE ENGINE VARIABLES ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- WORLD LIGHTING ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0x00ffff, 1.5);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        scene.add(sun);

        // --- TRACK & ENVIRONMENT ---
        // Creating a custom track shape using an Array
        const trackPoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(150, 0, 0),
            new THREE.Vector3(200, 0, 100),
            new THREE.Vector3(150, 0, 200),
            new THREE.Vector3(0, 0, 250),
            new THREE.Vector3(-150, 0, 150),
            new THREE.Vector3(-100, 0, 50),
            new THREE.Vector3(0, 0, 0)
        ];
        const trackCurve = new THREE.CatmullRomCurve3(trackPoints);
        const trackGeo = new THREE.TubeGeometry(trackCurve, 100, 12, 10, true);
        const trackMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.1 });
        const trackMesh = new THREE.Mesh(trackGeo, trackMat);
        trackMesh.receiveShadow = true;
        scene.add(trackMesh);

        // Grid Ground
        const grid = new THREE.GridHelper(2000, 100, 0x00ffff, 0x222222);
        grid.position.y = -1;
        scene.add(grid);

        // --- PHYSICS & KART LOGIC ---
        function createKart(color, isPlayer = false) {
            const kart = new THREE.Group();
            
            // Body Mesh
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.8, 4),
                new THREE.MeshStandardMaterial({ color: color, metalness: 0.8, roughness: 0.2 })
            );
            body.castShadow = true;
            kart.add(body);

            // Engine Block
            const engine = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1, 1),
                new THREE.MeshStandardMaterial({ color: 0x555555 })
            );
            engine.position.set(0, 0.5, -1.2);
            kart.add(engine);

            // Glowing Exhaust
            const exhaust = new THREE.PointLight(0xff0000, 2, 5);
            exhaust.position.set(0, 0, -2);
            kart.add(exhaust);

            scene.add(kart);
            return {
                mesh: kart,
                velocity: 0,
                angle: 0,
                drift: 0,
                speed: 0,
                accel: isPlayer ? 0.02 : 0.015,
                maxSpeed: isPlayer ? 1.5 : 1.2,
                friction: 0.98,
                turnSpeed: 0.05
            };
        }

        const player = createKart(0x00ff00, true);
        const bots = [
            createKart(0xff0000),
            createKart(0xffff00),
            createKart(0xff00ff)
        ];

        // --- INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // --- GAME LOOP ---
        let lapTime = 0;
        function updatePhysics() {
            // Player Input
            if (keys['ArrowUp'] || keys['KeyW']) player.speed += player.accel;
            if (keys['ArrowDown'] || keys['KeyS']) player.speed -= player.accel * 0.5;
            
            if (Math.abs(player.speed) > 0.05) {
                if (keys['ArrowLeft'] || keys['KeyA']) player.angle += player.turnSpeed;
                if (keys['ArrowRight'] || keys['KeyD']) player.angle -= player.turnSpeed;
            }

            // Apply Drift Momentum
            player.speed *= player.friction;
            player.mesh.rotation.y = player.angle;
            
            // Movement Vector
            player.mesh.position.x += Math.sin(player.angle) * player.speed;
            player.mesh.position.z += Math.cos(player.angle) * player.speed;

            // BOT AI: Path Following
            const time = Date.now() * 0.0005;
            bots.forEach((bot, i) => {
                const offset = (i + 1) * 0.1;
                const pos = trackCurve.getPointAt((time + offset) % 1);
                bot.mesh.position.copy(pos);
                // Face forward
                const nextPos = trackCurve.getPointAt((time + offset + 0.01) % 1);
                bot.mesh.lookAt(nextPos);
            });

            // Camera Follow
            const relativeCameraOffset = new THREE.Vector3(0, 5, -12);
            const cameraOffset = relativeCameraOffset.applyMatrix4(player.mesh.matrixWorld);
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(player.mesh.position);

            // Update UI
            document.getElementById('speed').innerText = Math.floor(player.speed * 100) + " KM/H";
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        animate();

        // Mobile Button Support
        const btnL = document.getElementById('btn-left');
        const btnR = document.getElementById('btn-right');
        const btnA = document.getElementById('btn-accel');

        btnL.onpointerdown = () => keys['KeyA'] = true;
        btnL.onpointerup = () => keys['KeyA'] = false;
        btnR.onpointerdown = () => keys['KeyD'] = true;
        btnR.onpointerup = () => keys['KeyD'] = false;
        btnA.onpointerdown = () => keys['KeyW'] = true;
        btnA.onpointerup = () => keys['KeyW'] = false;

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
